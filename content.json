{"meta":{"title":"Nobody can save you but yourself","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"浏览器 V8引擎","date":"2021-04-10T10:25:36.000Z","updated":"2021-04-06T11:16:11.324Z","comments":true,"path":"V8 engine(待.html","permalink":"http://example.com/V8%20engine(%E5%BE%85.html","excerpt":"值类型任何高级编程语言编译之前都是要先做词法语法分析。所以正确的顺序是，语法分析-&gt;保存语法分析结果ast-&gt;编译为字节码-&gt;机器码。优化后的V8：语法分析-&gt;语法分析结果ast-&gt;解释执行-&gt;回收ast空间-&gt;性能分析-&gt;热点函数-&gt;持久化为机器码-&gt;非热点函数-&gt;回退到ast-&gt;由解释器执行 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型任何高级编程语言编译之前都是要先做词法语法分析。所以正确的顺序是，语法分析-&gt;保存语法分析结果ast-&gt;编译为字节码-&gt;机器码。优化后的V8：语法分析-&gt;语法分析结果ast-&gt;解释执行-&gt;回收ast空间-&gt;性能分析-&gt;热点函数-&gt;持久化为机器码-&gt;非热点函数-&gt;回退到ast-&gt;由解释器执行 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"},{"title":"计算机网络概论 学习笔记","date":"2021-04-15T11:53:25.000Z","updated":"2021-04-06T11:32:18.604Z","comments":true,"path":"how networks work(待.html","permalink":"http://example.com/how%20networks%20work(%E5%BE%85.html","excerpt":"值类型任何高级编程语言编译之前都是要先做词法语法分析。所以正确的顺序是，语法分析-&gt;保存语法分析结果ast-&gt;编译为字节码-&gt;机器码。优化后的V8：语法分析-&gt;语法分析结果ast-&gt;解释执行-&gt;回收ast空间-&gt;性能分析-&gt;热点函数-&gt;持久化为机器码-&gt;非热点函数-&gt;回退到ast-&gt;由解释器执行 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型任何高级编程语言编译之前都是要先做词法语法分析。所以正确的顺序是，语法分析-&gt;保存语法分析结果ast-&gt;编译为字节码-&gt;机器码。优化后的V8：语法分析-&gt;语法分析结果ast-&gt;解释执行-&gt;回收ast空间-&gt;性能分析-&gt;热点函数-&gt;持久化为机器码-&gt;非热点函数-&gt;回退到ast-&gt;由解释器执行 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"}],"posts":[{"title":"浏览器运行原理","slug":"browser works","date":"2021-04-15T06:03:43.000Z","updated":"2021-04-30T06:04:03.112Z","comments":true,"path":"2021/04/15/browser works/","link":"","permalink":"http://example.com/2021/04/15/browser%20works/","excerpt":"用户界面展示除标签页窗口外的其它用户界面内容 浏览器引擎在用户界面和渲染引擎之间传递数据 渲染引擎（内核）渲染用户请求的页面内容","text":"用户界面展示除标签页窗口外的其它用户界面内容 浏览器引擎在用户界面和渲染引擎之间传递数据 渲染引擎（内核）渲染用户请求的页面内容 当启动某个程序时，系统会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要通过进程间通信管道 IPC 来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死的时候，由于进程间相互独立，不会影响到整个应用程序。进程可以将任务分成多个更细小的任务，然后通过创建多个线程，并行执行不同的任务。同一进程下的线程之间是可以直接通信共享数据的。 早期的浏览器并不是多进程的结构，而是个单进程结构。单进程结构引发的问题: （1）不稳定，其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，有一个标签页卡死，可能会导致整个浏览器无法正常运行。 （2）不安全，线程之间是可以共享数据的，线程可以随意访问进程内的数据。 （3）不流畅，一个进程需要负责太多事情，影响运行效率。 多进程浏览器结构: 根据进程功能不同来拆解浏览器，如网络进程负责发起接受网络请求，GPU 进程负责图形渲染，插件进程负责控制网站使用的所有插件（例如 Flash ），渲染器进程用来控制显示tab标签内的所有内容。 浏览器（ chrome 为例）在默认情况下会为每个标签页都创建一个进程: 为用户访问的网站的每个实例创建一个渲染器进程。这样可以确保来自不同站点的页面是独立呈现的，并且对同一站点的单独访问也是彼此隔离的。简单来说就是访问不同站点和同一站点的不同页面都会创建新进程。如果网页中嵌入了 iframe ， chrome 会出于安全考虑为每个 iframe 都创建了一个进程，通过多进程让当前的主站点和 iframe 里的站点之间隔离。 四种进程模型（文档地址: https://www.chromium.org/developers/design-documents/process-models ）: 默认的 Process-per-site-instance Process-per-site: 同一站点使用同一进程。 Process-per-tab: 一个tab里的所有站点使用一个进程。 Single process: 让浏览器引擎和渲染器引擎共用一个进程。 Process-per-site-instance 模型会创建更多的进程占用更多的内存空间，但最安全。每个标签，以及标签内的每个站点都是相互隔离互不影响的。当其中一个标签页里渲染器进程卡死，并不会影响其他标签。 浏览器渲染原理当在地址栏输入地址时，浏览器进程的 UI 线程会捕捉输入内容，如果访问的是网址，则 UI 线程会启动一个网络线程来请求 DNS 进行域名解析接着开始连接服务器获取数据。如果输入的是一串关键词，就会使用默认配置的搜索引擎来查询。 当网络线程获取到数据后，会通过 SafeBrowsing （谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如通过查看该站点的 ip 是否在他们的黑名单内）来检查该站点的是否是恶意站点。如果是则会展示个警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问。当然也可以强行继续访问。 当返回数据准备完毕并且安全校验通过，网络线程会通知 UI 线程，然后 UI 线程会创建一个渲染器进程来渲染页面。浏览器进程通过 IPC 管道将数据（ html ）传递给渲染器进程，正式进入渲染流程。渲染器进程的核心任务就是把 html 、 js 、 css 、 img 等资源渲染成用户可交互的web页面。此时地址栏的状态更新，比如 histroy 更新，现在可以点击导航栏的后退。 渲染器进程的主线程将 html 进行解析，构造 DOM 数据结构。 DOM 文档对象模型是浏览器对页面在其内部表示形式，是 Web 程序员可以通过 JavaScript 与之交互的数据结构和 API 。 HTML 首先经过 Tokeniser 标记化，通过词法分析，将输入 html 内容解析成多个标记，根据识别后的标记进行 DOM 树构造, 在 DOM 树构造过程中会创建 Document 对象，然后以 Document 为根节点的DOM树不断进行修改，向其中添加各种元素。 HTML 代码中往往会引入一些额外的资源，比如图片， css 和 js 脚本等。图片和 css 这些资源需要通过网络下载或者从缓存中直接加载。这些资源不会阻塞 html 的解析，因为他们不会影响 DOM 的生成，但当 html 解析过程中遇到script标签，将停止 html 解析流程，转而去加载解析并且执行 js （浏览器不知道 js 的执行是否会改变当前页面的 html 的结构，比如 js 代码了调用 document.write 方法来修改 html ，那之前的 html 的解析就失去意义，所以要把 script 标签要放在合适的位置，或者使用 async 或 defer 属性来异步加载执行 js ）。 在 html 解析完成后，我们就获得一个 dom tree ，但我们还不知道 dom tree 上每个节点应该长什么样。主线程需要解析 css 并确定每个 DOM 节点的 css 样式（浏览器有自己的默认的样式表）。 在知道 dom 结构和每个节点的样式后，需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标，以及该节点需要占用多大的区域。 这个阶段被称为 layout 布局，主线程通过遍历 DOM 和计算好的样式来生成 layout tree ， layout tree 上的每个节点都记录 x 、 y 坐标和边框尺寸。因为 DOM 是通过 html 解析获得，并不关心样式。而 layout tree 是根据 dom tree 和计算好的样式来生成， layout tree 是和最后展示在屏幕上的的节点是对应的。所以 DOM Tree 和 layout tree 并不是一一对应的，设置了 display: none 的节点不会出现在 layout tree 上，而在 before 伪类中添加了 content 值的元素， content 的内容会出现在 layout tree ，不会出现在 DOM 树里。 已经知道元素的大小，形状和位置后还需要知道绘制各个节点的顺序。例: z-index 这个属性会影响节点绘制的层级关系。如果按照 dom 的层级结构来绘制页面，则会导致错误的渲染。 所以为了保证在屏幕上展示正确的层级，在绘制阶段，主线程遍历 layout tree 创建一个绘制记录表，该表记录了绘制的顺序。 知道了文档的绘制顺序后就到了该把这些信息转化成像素点显示在屏幕上了。这种行为，被称为栅格化（ rasterizing ）。浏览器最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式会导致展示延迟。随着不断的优化升级，现在使用了一种更复杂的栅格化流程，叫做 compositing 组合: 一种将页面的各个部分分成多个图层，分别对其进行栅格化并在合成器线程 compositor thread 的单独线程中进行合成页面的技术。简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化，然后只需要把可视区的内容组合成一帧展示给用户。 主线程遍历 layout tree 生成 layer tree ，当 layer tree 生成完毕和绘制顺序确定后，主线程将这些信息传递给 compositor 线程。合成器线程将每个图层栅格化。一层可能像页面的整个长度一样大，因此合成器线程将它们切分为多个图块，然后将每个图块发送给栅格线程。 栅格线程栅格化每个图块并将它们存储在 GPU 内存中。对图块进行栅格化后合成器线程可以给不同的栅格线程分别优先级，比如栅格化可视区域图块的栅格线程优先处理。 当图块栅格化完成后，合成器线程将收集称为 draw quads 图块信息，这些信息里记录了包含诸如图块在内存中的位置和在页面的哪个位置绘制图块的信息。根据这些数据合成器线程生成了一个合成器 frame 。然后 frame 通过 IPC 传送给浏览器进程， 接着浏览器进程将 compositor frame 传到 GPU ，然后 GPU 渲染展示到屏幕上。于是你终于看到了页面内容。当页面发生变化，比如你滚动了当前页面，则会生成一个新的 compositor frame ，新的 frame 再传给 GPU 。再次渲染到屏幕上。 重排：当我们改变一个尺寸位置属性时，会重新进行样式计算，布局，绘制，以及后面的所有流程。 重绘：当我们改变某个元素的颜色属性时，不会重新触发布局，但还是触发会样式计算和绘制。 重排和重绘会占用主线程，还有一个东西的运行也是在主线程。对， js 。既然他们都是在主线程就会出现抢占执行时间的问题。 如果写了个不断导致重绘重排的动画，浏览器则需要在每一帧都会运行样式计算、布局和绘制的操作，当页面以每秒大于60帧的刷新率刷新，用户才不会感觉到页面卡顿。 如果在运行动画时，有大量的 js 任务需要执行，因为布局绘制和 js 的执行都是在主线程运行的，当在一帧的时间内，布局和绘制结束后，还有剩余时间， js 就会拿到主线程的使用权，如果 js 执行时间过长就会导致在下一帧开始时， js 没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿。优化手段: 第一种：就是可以通过 requestAnimationFrame 这个 api 来帮助我们解决这个问题。 requestAnimationFrame 这个方法会在每一帧被调用，通过这个 api 的回调参数，我们可以知道每一帧当前还剩余的，我们可以把 js 运行任务分成一些小块，在时间用完前，归还主线程。 第二种：栅格化整个流程是不占用主线程的，只在合成器和栅格线程中运行，这就意味着它无需和 js 抢夺的主线程。刚才提到，如果我们反复重绘和重排，可能会导致掉帧，因为有可能会有 js 的执行阻塞了主线程。 css 中有个动画属性叫 transform ，通过该属性实现的动画，不会经过布局和绘制，而是直接运行在 compositor 和 rasterizing 线程中，所以不会受到主线程中js执行的影响。更重要的是 transform 的动画，由于不需要经过布局绘制样式计算，所以节省了很多运算时间。可以让复杂的动画更加流畅。我们常常会哪些属性来实现动画效果呢，位置变化，宽高变化，那这些都可以使用 transform 来代替。","categories":[],"tags":[]},{"title":"JS 事件循环","slug":"js event loop","date":"2021-04-06T07:37:55.000Z","updated":"2021-04-19T14:52:13.067Z","comments":true,"path":"2021/04/06/js event loop/","link":"","permalink":"http://example.com/2021/04/06/js%20event%20loop/","excerpt":"关于 JS 异步js 作为浏览器端的脚本语言，主要的用途为用户与服务端的交互与操作 dom 。而操作 dom 就注定了 js 只能是单线程语言，假如多个线程同时对一个 dom 进行操作则浏览器无法判断如何渲染。（在浏览器中 js 引擎负责解释和执行JavaScript代码的线程只有一个）。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。同步会阻塞代码的执行，而异步不会。事件循环（event loop）是 js 异步的实现方式。","text":"关于 JS 异步js 作为浏览器端的脚本语言，主要的用途为用户与服务端的交互与操作 dom 。而操作 dom 就注定了 js 只能是单线程语言，假如多个线程同时对一个 dom 进行操作则浏览器无法判断如何渲染。（在浏览器中 js 引擎负责解释和执行JavaScript代码的线程只有一个）。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。同步会阻塞代码的执行，而异步不会。事件循环（event loop）是 js 异步的实现方式。 事件循环的三个部分：调用栈call stack循环开始后从全局栈开始一行一行执行，遇到函数调用就压入调用栈中（压入的函数称为帧frame）,函数返回后从调用栈弹出 消息队列message quenesetTimeout、setInterval、setlmmediate等异步操作的回调函数会入队到消息队列，在调用栈清空后执行（一个循环结束后），执行顺序为先进先出 js 异步操作主要有： 1、定时任务（setTimeout、setInterval） 2、网路请求（ajax、动态加载） 3、事件处理函数绑定（click，focus，change等） 微任务队列microtask quenePromise回调、await、async、MutationObserver等操作会入队到微任务队列，在调用栈清空时立即执行，处理时新加入的微任务也一起执行（一个循环结束时） 示例代码:1234567891011121314151617181920212223242526272829303132var p = new Promise(resolve =&gt; &#123; console.log(4); resolve(5);&#125;);function fun1() &#123; console.log(1);&#125;function fun2() &#123; setTimeout(() =&gt; &#123; console.log(2); &#125;); fun1(); console.log(3); p.then(resolved =&gt; &#123; console.log(resolved) &#125;) .then(() =&gt; &#123; console.log(6) &#125;);&#125;fun2();// 打印顺序为413562for(var i = 0; i&lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i++); &#125;)&#125;console.log(i);//打印顺序为556789","categories":[],"tags":[]},{"title":"JS 防抖和节流","slug":"debounce and throttle","date":"2021-04-03T14:22:14.000Z","updated":"2021-04-03T14:23:05.708Z","comments":true,"path":"2021/04/03/debounce and throttle/","link":"","permalink":"http://example.com/2021/04/03/debounce%20and%20throttle/","excerpt":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想","text":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想 1234567let timer &#x3D; null;aElement.click &#x3D; function&#123; clearTimeout(time); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; console.log(&quot;debounce successfully&quot;) &#125;, 1000)&#125; 节流减少事件的触发, 降低触发频率（在产生事件时判断节流阀，成立时（true）把节流阀设置为不成立（false）, 触发事件, 开启新计时器重置节流阀（true）) 12345678let flag = true;if(flag)&#123; flag = false; console.log(&quot;throttle successfully&quot;); setTimeout(() =&gt; &#123; flag = true; &#125;, 1000)&#125; 前往 https://www.lodashjs.com/ 获取封装好的方法: .debounce、.throttle（利用script标签引用网站的lodash.js文件）","categories":[],"tags":[]},{"title":"JS 浅拷贝和深拷贝","slug":"deepcopy and shallowcopy","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"2021/04/03/deepcopy and shallowcopy/","link":"","permalink":"http://example.com/2021/04/03/deepcopy%20and%20shallowcopy/","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))","categories":[],"tags":[]},{"title":"跨域（Cross-origin resource sharing）相关","slug":"about the CORS","date":"2021-04-01T00:43:44.697Z","updated":"2021-04-01T15:58:28.345Z","comments":true,"path":"2021/04/01/about the CORS/","link":"","permalink":"http://example.com/2021/04/01/about%20the%20CORS/","excerpt":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互","text":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互 常见解决方案: （1）HTML特殊标签 link、script、img、frame等标签具有跨域特性, 可直接访问 （2）cors 普通跨域请求只需服务器端设置（以php为例） 1header(“Access-Control-Allow-Origin: *”) 带cookie跨域请求：前后端都需要进行设置 ? （3）proxy代理（开发环境用proxy，生产环境用nginx反向代理） 利用服务器对数据进行转发, 以proxy为例 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; &quot;/api&quot;: &#123; //表示是否需要跨域，接口地址以/api开头则跨域 target: &quot;&quot;, //设置调用的接口域名和端口号 changeOrigin: ture, //开启代理，在本地创建一个虚拟服务器 pathRewrite:&#123; &quot;^api&quot;: &quot;/&quot; &#125; &#125; &#125; &#125;&#125; （4）jsonp 利用script标签远程动态加载js代码, 只支持get方法 123456$ajax(&#123; type: &quot;get&quot;, url: &quot;&quot;, dataType: &quot;jsonp&quot;, success: function (response)&#123;&#125;&#125;)","categories":[],"tags":[]},{"title":"关于HTML语义化","slug":"html semantic meaning","date":"2021-03-31T00:35:16.572Z","updated":"2021-04-03T13:46:21.372Z","comments":true,"path":"2021/03/31/html semantic meaning/","link":"","permalink":"http://example.com/2021/03/31/html%20semantic%20meaning/","excerpt":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。","text":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。 部分语义化标签示意: 选用html标签的注意事项：​ （1）少用无语义的标签div和span； ​ （2）既可以使用div或者p时尽量用p: 因为p在默认情况下有上下间距，有利于兼容特殊终端； ​ （3）需要强调的文本，可以包含在strong或em标签中，strong默认样式是加粗（不要用b），em是斜体（不要用i）； ​ （4）每个input标签对应的说明文本都需要使用label标签，在lable标签中设置 for = id 来关联说明文本和相对应的input； 常见语义化标签:​ hn：h1~h6，分级标题，h1 与 title 协调有利于搜索引擎优化 ​ ul：无序列表 ​ ol：有序列表 ​ header：页眉通常包括网站标志、主导航、全站链接以及搜索框 ​ nav：标记导航，仅对文档中重要的链接群使用 ​ main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能 ​ article：定义外部的内容，其中的内容独立于文档的其余部分 ​ section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 ​ aside：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等 ​ footer：页脚，只有当父级是body时，才是整个页面的页脚 ​ small：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权 ​ strong：和 em 标签一样，用于强调文本，但它强调的程度更强一些 ​ em：将其中的文本表示为强调的内容，表现为斜体 ​ mark：使用黄色突出显示部分文本 ​ figure：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin） ​ figcaption：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置 ​ cite：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题 ​ blockquoto：定义块引用，块引用拥有它们自己的空间 ​ time：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式 ​ abbr：简称或缩写 ​ dfn：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用 ​ del：移除的内容 ​ ins：添加的内容 ​ code：标记代码 ​ meter：定义已知范围或分数值内的标量测量 ​ progress：定义运行中的进度（进程）","categories":[],"tags":[]},{"title":"flex布局 用法记录","slug":"flex use","date":"2021-03-29T13:30:40.890Z","updated":"2021-03-31T08:43:48.430Z","comments":true,"path":"2021/03/29/flex use/","link":"","permalink":"http://example.com/2021/03/29/flex%20use/","excerpt":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素）","text":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素） flex模型相关尺寸:flex constainer的css属性：flex-flow（缩写，flex-direction||flex-wrap） flex-direction（决定主轴方向）: row（默认）, row-reverse，column（主轴从上到下），column-reverse flex-wrap（单行/多行）: nowrap，wrap，wrap-reverse justify-content（决定flex items在main-axis上的对齐方式）: flex-start（默认），flex-end，center，space-between，space-evenly，space-around align-items（决定flex items在cross-axis上的对齐方式）: normal（默认），strech（效果同normal, flex items在cross-axis方向的size为auto时, 自动拉伸），flex-start，flex-end，center，baseline align-content（决定多行flex-items在cross axis上的对齐方式）: strech，flex-start，flex-end，center，space-berween，space-around，space-evenly flex items的css属性:flex（缩写，flex-grow||flex-shrink||flex-basis） flex-grow（决定flex items如何扩展，flex container在main axis方向有剩余size时才生效）: 可设置任意非负数，所有flex items的flex-grow总和 sum 超过1，扩展size为 剩余size * flex-grow / sum ，不超过1时扩展size为 剩余size * flex-grow flex-shrink（决定flex items如何收缩, flex items在main axis方向上超过flex container的size时才生效）: 可设置任意非负数，收缩后的size不能小于min-width/min-height，所有flex items的flex-shrink总和 sum 超过1，收缩的size为 超出size * flex-shrink * items base size / sum ，不超过1时收缩的size为 超出size * flex-shrink * items base size flex-basis（设置flex items在main axis方向上的base size）: auto， 具体数值（？px） 生效的优先级: （1）max-width/max-height/min-width/min-height （2）flex-basis （3）width/higth （4）自身size order（决定flex-items排布顺序，设置任意整数，值越小排布越靠前） align-self（单独效果，覆盖flex container设置的align-items）: auto（默认），stretch，flex-start，flex-end，center，baseline","categories":[],"tags":[]},{"title":"vue.js 学习笔记","slug":"vuejs learning","date":"2021-03-29T11:32:44.000Z","updated":"2021-03-29T11:41:15.738Z","comments":true,"path":"2021/03/29/vuejs learning/","link":"","permalink":"http://example.com/2021/03/29/vuejs%20learning/","excerpt":"","text":"vue框架vue","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-29T11:13:57.110Z","updated":"2021-03-29T13:12:17.543Z","comments":true,"path":"2021/03/29/hello-world/","link":"","permalink":"http://example.com/2021/03/29/hello-world/","excerpt":"","text":"2021.3.29 Set up my blog successfully","categories":[],"tags":[]}],"categories":[],"tags":[]}