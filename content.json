{"meta":{"title":"Nobody can save you but yourself","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JS 防抖和节流","slug":"debounce and throttle","date":"2021-04-03T14:22:14.000Z","updated":"2021-04-03T14:23:05.708Z","comments":true,"path":"2021/04/03/debounce and throttle/","link":"","permalink":"http://example.com/2021/04/03/debounce%20and%20throttle/","excerpt":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想","text":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想 1234567let timer &#x3D; null;aElement.click &#x3D; function&#123; clearTimeout(time); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; console.log(&quot;debounce successfully&quot;) &#125;, 1000)&#125; 节流减少事件的触发, 降低触发频率（在产生事件时判断节流阀，成立时（true）把节流阀设置为不成立（false）, 触发事件, 开启新计时器重置节流阀（true）) 12345678let flag = true;if(flag)&#123; flag = false; console.log(&quot;throttle successfully&quot;); setTimeout(() =&gt; &#123; flag = true; &#125;, 1000)&#125; 前往 https://www.lodashjs.com/ 获取封装好的方法: .debounce、.throttle（利用script标签引用网站的lodash.js文件）","categories":[],"tags":[]},{"title":"JS 浅拷贝和深拷贝","slug":"deepcopy and shallowcopy","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"2021/04/03/deepcopy and shallowcopy/","link":"","permalink":"http://example.com/2021/04/03/deepcopy%20and%20shallowcopy/","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))","categories":[],"tags":[]},{"title":"跨域（Cross-origin resource sharing）相关","slug":"about the CORS","date":"2021-04-01T00:43:44.697Z","updated":"2021-04-01T15:58:28.345Z","comments":true,"path":"2021/04/01/about the CORS/","link":"","permalink":"http://example.com/2021/04/01/about%20the%20CORS/","excerpt":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互","text":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互 常见解决方案: （1）HTML特殊标签 link、script、img、frame等标签具有跨域特性, 可直接访问 （2）cors 普通跨域请求只需服务器端设置（以php为例） 1header(“Access-Control-Allow-Origin: *”) 带cookie跨域请求：前后端都需要进行设置 ? （3）proxy代理（开发环境用proxy，生产环境用nginx反向代理） 利用服务器对数据进行转发, 以proxy为例 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; &quot;/api&quot;: &#123; //表示是否需要跨域，接口地址以/api开头则跨域 target: &quot;&quot;, //设置调用的接口域名和端口号 changeOrigin: ture, //开启代理，在本地创建一个虚拟服务器 pathRewrite:&#123; &quot;^api&quot;: &quot;/&quot; &#125; &#125; &#125; &#125;&#125; （4）jsonp 利用script标签远程动态加载js代码, 只支持get方法 123456$ajax(&#123; type: &quot;get&quot;, url: &quot;&quot;, dataType: &quot;jsonp&quot;, success: function (response)&#123;&#125;&#125;)","categories":[],"tags":[]},{"title":"关于HTML语义化","slug":"html semantic meaning","date":"2021-03-31T00:35:16.572Z","updated":"2021-04-03T13:46:21.372Z","comments":true,"path":"2021/03/31/html semantic meaning/","link":"","permalink":"http://example.com/2021/03/31/html%20semantic%20meaning/","excerpt":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。","text":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。 部分语义化标签示意: 选用html标签的注意事项：​ （1）少用无语义的标签div和span； ​ （2）既可以使用div或者p时尽量用p: 因为p在默认情况下有上下间距，有利于兼容特殊终端； ​ （3）需要强调的文本，可以包含在strong或em标签中，strong默认样式是加粗（不要用b），em是斜体（不要用i）； ​ （4）每个input标签对应的说明文本都需要使用label标签，在lable标签中设置 for = id 来关联说明文本和相对应的input； 常见语义化标签:​ hn：h1~h6，分级标题，h1 与 title 协调有利于搜索引擎优化 ​ ul：无序列表 ​ ol：有序列表 ​ header：页眉通常包括网站标志、主导航、全站链接以及搜索框 ​ nav：标记导航，仅对文档中重要的链接群使用 ​ main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能 ​ article：定义外部的内容，其中的内容独立于文档的其余部分 ​ section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 ​ aside：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等 ​ footer：页脚，只有当父级是body时，才是整个页面的页脚 ​ small：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权 ​ strong：和 em 标签一样，用于强调文本，但它强调的程度更强一些 ​ em：将其中的文本表示为强调的内容，表现为斜体 ​ mark：使用黄色突出显示部分文本 ​ figure：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin） ​ figcaption：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置 ​ cite：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题 ​ blockquoto：定义块引用，块引用拥有它们自己的空间 ​ time：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式 ​ abbr：简称或缩写 ​ dfn：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用 ​ del：移除的内容 ​ ins：添加的内容 ​ code：标记代码 ​ meter：定义已知范围或分数值内的标量测量 ​ progress：定义运行中的进度（进程）","categories":[],"tags":[]},{"title":"flex布局 用法记录","slug":"flex use","date":"2021-03-29T13:30:40.890Z","updated":"2021-03-31T08:43:48.430Z","comments":true,"path":"2021/03/29/flex use/","link":"","permalink":"http://example.com/2021/03/29/flex%20use/","excerpt":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素）","text":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素） flex模型相关尺寸:flex constainer的css属性：flex-flow（缩写，flex-direction||flex-wrap） flex-direction（决定主轴方向）: row（默认）, row-reverse，column（主轴从上到下），column-reverse flex-wrap（单行/多行）: nowrap，wrap，wrap-reverse justify-content（决定flex items在main-axis上的对齐方式）: flex-start（默认），flex-end，center，space-between，space-evenly，space-around align-items（决定flex items在cross-axis上的对齐方式）: normal（默认），strech（效果同normal, flex items在cross-axis方向的size为auto时, 自动拉伸），flex-start，flex-end，center，baseline align-content（决定多行flex-items在cross axis上的对齐方式）: strech，flex-start，flex-end，center，space-berween，space-around，space-evenly flex items的css属性:flex（缩写，flex-grow||flex-shrink||flex-basis） flex-grow（决定flex items如何扩展，flex container在main axis方向有剩余size时才生效）: 可设置任意非负数，所有flex items的flex-grow总和 sum 超过1，扩展size为 剩余size * flex-grow / sum ，不超过1时扩展size为 剩余size * flex-grow flex-shrink（决定flex items如何收缩, flex items在main axis方向上超过flex container的size时才生效）: 可设置任意非负数，收缩后的size不能小于min-width/min-height，所有flex items的flex-shrink总和 sum 超过1，收缩的size为 超出size * flex-shrink * items base size / sum ，不超过1时收缩的size为 超出size * flex-shrink * items base size flex-basis（设置flex items在main axis方向上的base size）: auto， 具体数值（？px） 生效的优先级: （1）max-width/max-height/min-width/min-height （2）flex-basis （3）width/higth （4）自身size order（决定flex-items排布顺序，设置任意整数，值越小排布越靠前） align-self（单独效果，覆盖flex container设置的align-items）: auto（默认），stretch，flex-start，flex-end，center，baseline","categories":[],"tags":[]},{"title":"vue.js 学习笔记","slug":"vuejs learning","date":"2021-03-29T11:32:44.000Z","updated":"2021-03-29T11:41:15.738Z","comments":true,"path":"2021/03/29/vuejs learning/","link":"","permalink":"http://example.com/2021/03/29/vuejs%20learning/","excerpt":"","text":"vue框架vue","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-29T11:13:57.110Z","updated":"2021-03-29T13:12:17.543Z","comments":true,"path":"2021/03/29/hello-world/","link":"","permalink":"http://example.com/2021/03/29/hello-world/","excerpt":"","text":"2021.3.29 Set up my blog successfully","categories":[],"tags":[]}],"categories":[],"tags":[]}