{"meta":{"title":"Nobody can save you but yourself","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"JS 浅拷贝和深拷贝","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"实现换肤功能（待.html","permalink":"http://example.com/%E5%AE%9E%E7%8E%B0%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E5%BE%85.html","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"},{"title":"JS 浅拷贝和深拷贝","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"正则（待.html","permalink":"http://example.com/%E6%AD%A3%E5%88%99%EF%BC%88%E5%BE%85.html","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"},{"title":"JS 浅拷贝和深拷贝","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"对象方法（待.html","permalink":"http://example.com/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%BE%85.html","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"},{"title":"JS 浅拷贝和深拷贝","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"组件编译（待.html","permalink":"http://example.com/%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%EF%BC%88%E5%BE%85.html","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"},{"title":"JS 浅拷贝和深拷贝","date":"2021-04-03T13:47:40.000Z","updated":"2021-04-03T14:23:34.125Z","comments":true,"path":"虚拟dom（待.html","permalink":"http://example.com/%E8%99%9A%E6%8B%9Fdom%EF%BC%88%E5%BE%85.html","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj = a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化（如果对象里含有方法则该方法无法被序列化，该部分会被丢弃） 1JSON.parse(JSON.stringify(object))"}],"posts":[{"title":"vue数据劫持函数","slug":"vuejs data hijack","date":"2021-11-09T06:45:26.000Z","updated":"2022-01-03T15:30:02.315Z","comments":true,"path":"2021/11/09/vuejs data hijack/","link":"","permalink":"http://example.com/2021/11/09/vuejs%20data%20hijack/","excerpt":"一、 vue2.0数据劫持核心函数Object.defineProperty","text":"一、 vue2.0数据劫持核心函数Object.defineProperty 过程1、vue2.0为options api，将一个对象传入vue函数 2、若传入对象中存在data项，则进行初始化操作 3、判断data是否为函数或对象或其它，若为函数则执行并调用apply函数将其this指向改变为vue实例，将函数执行返回的对象保存挂载至实例，通过Object.defineProperty实现实例用点语法直接访问数据（对象属性） 4、观察函数阶段，若传入观察函数的值为非Object类型或null则返回，除此之外对该值进行观察（满足观察条件） 5、进入观察后判断传入值是否为数组类型 5.1、非数组类型 使用Object.defineProperty进行劫持，如果此时传入Object.defineProperty的值为对象或数组则进行递归操作（传入观察函数）。另在赋值操作的时候需判断新赋予的值的类型，决定是否对其进行观察（传入观察函数） 5.2、数组类型 重写数组的七种方法（会更改原数组的方法，可能导致视图需要更新）：push、pop、shift、unshift、splice、sort、reverse，在原型链上用新方法遮蔽原方法 重写方法的作用：将传入的参数（arguments，参数个数不固定）用Array.prototype.slice.call(arguments)转化为一个新数组：（一）将该数组传入根据数组方法的原型对象新建（复制）的新对象，即功能由原来的函数实现；（二）判断是否存在新增加的值（push、unshift方法，若是splice则用.slice(2)观察第三项以后的参数），存在则进行遍历并观察（观察函数阶段，传入观察函数） 二、 vue3.0数据劫持核心函数proxy 过程： 1、vue3.0为compostion api，可以将所需用到的功能函数（方法）从vue的包中（node包）单独解构出来使用 2、以reative函数为例：传入参数，将该参数用proxy构造函数代理后用 return 返回 3、创建响应式对象：判断传入参数的类型，若为对象且不为 null（否则直接返回参数，不代理），则用proxy的handle函数创建get、set或其他操作的拦截器，对应拦截器的操作方法使用 Reflect（内置的对象，像一个方法管理器，非构造函数）中的方法完成 4、递归操作：在get拦截器内判断当前经 Reflect.get方法处理后的返回值的类型是否为对象且不为 null，若符合条件则再次进行响应式对象的创建 5、在set拦截器内判断是否有新增或修改数据的操作（Object.prototype.hasOwnProperty.call(target , key); ）,以便往后扩展功能","categories":[],"tags":[]},{"title":"浏览器 V8引擎","slug":"V8 engine","date":"2021-07-05T03:30:36.000Z","updated":"2022-01-03T15:30:18.622Z","comments":true,"path":"2021/07/05/V8 engine/","link":"","permalink":"http://example.com/2021/07/05/V8%20engine/","excerpt":"解析器作用：JS源代码解析成抽象语法树AST（只声明但不被调用的函数不生成AST） 解释器作用：AST语法树解释成字节码bytecode 编译器作用：字节码bytecode编译成更高效的机器代码","text":"解析器作用：JS源代码解析成抽象语法树AST（只声明但不被调用的函数不生成AST） 解释器作用：AST语法树解释成字节码bytecode 编译器作用：字节码bytecode编译成更高效的机器代码 运行过程解析器将JS源代码解析成抽象语法树AST，解释器生成并解析字节码bytecode后清除AST，解释器收集运行代码过程中的优化信息（如多次调用某个函数（热点函数）），将信息发送给编译器，编译器根据字节码和优化信息编译出优化后的机器代码，执行效率更高。 如改变传入热点函数的变量类型，可能使得优化的机器代码逆向还原成字节码，由解释器执行 总结任何高级编程语言编译之前都是要先做词法语法分析，正确的顺序是：语法分析-&gt;保存语法分析结果AST-&gt;编译为字节码-&gt;机器码 而V8引擎：语法分析-&gt;语法分析结果AST-&gt;解释执行-&gt;回收AST空间-&gt;性能分析-&gt;热点函数-&gt;持久化为机器代码-&gt;非热点函数（函数参数类型更改）-&gt;回退到AST-&gt;由解释器执行","categories":[],"tags":[]},{"title":"JS 数组去重","slug":"JS array deduplication","date":"2021-06-16T14:35:44.000Z","updated":"2021-07-10T17:04:53.190Z","comments":true,"path":"2021/06/16/JS array deduplication/","link":"","permalink":"http://example.com/2021/06/16/JS%20array%20deduplication/","excerpt":"数组去重方法：1. Set1let result = [...new Set(arr)]","text":"数组去重方法：1. Set1let result = [...new Set(arr)] 2. indexOf1234567891011let result = [];arr.forEach(item =&gt; &#123; if(result.indexOf(item == -1)&#123; result.push(item); &#125;)&#125;) 3. filter、indexOf12345let result = arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index;&#125; 4. reduce12345let result = arr.reduce((pre, item) =&gt; &#123; return pre.includes(item) ? pre : [...pre, item]&#125;, []); 5. map、Object.keys()123456789let result = [];arr.forEach((item, index) =&gt; &#123; result[arr[index]] = &#x27;value&#x27;;&#125;)result = Object.keys(result).map(item =&gt; ~~item); 6. for12345678910111213141516171819202122232425var result = [];var flag;for (let i = 0; i &lt; arr.length; i ++)&#123; flag = false; for (let j = i + 1; j &lt; arr.length; j ++)&#123; if (arr[i] === arr[j])&#123; flag = true; &#125; &#125; if (!flag)&#123; result.push(arr[i]); &#125; &#125; 7. sort12345678910111213var result = [];var temp = arr.sort();for(let i = 0;i &lt; temp.length;i ++)&#123; if(temp[i] !== temp[i+1])&#123; result.push(arr[i]); &#125;&#125;","categories":[],"tags":[]},{"title":"JavaScript 红宝书学习笔记","slug":"P Js learning","date":"2021-05-21T11:45:12.000Z","updated":"2021-07-10T17:04:46.912Z","comments":true,"path":"2021/05/21/P Js learning/","link":"","permalink":"http://example.com/2021/05/21/P%20Js%20learning/","excerpt":"语言基础标识符：变量、函数、属性或函数参数的名称 var声明提升：把变量拉到函数作用域顶部 var声明范围：函数作用域 let声明范围：块作用域，声明不会提升，不能依赖条件声明模式 const 声明时必须初始化变量","text":"语言基础标识符：变量、函数、属性或函数参数的名称 var声明提升：把变量拉到函数作用域顶部 var声明范围：函数作用域 let声明范围：块作用域，声明不会提升，不能依赖条件声明模式 const 声明时必须初始化变量 6种原始类型：Undefined、Null、Boolean、Number、String、Symbol typeof：确定变量数据类型 null是一个假值，表示一个空对象指针 NaN：特殊数值，表示本来要返回数值的操作失败了（而不是抛出错误） isNaN：尝试把值转换成数值 将非数值转换为数值：Number()，parseInt()、parseFloat() 将值转换成字符串：toString()、String() 逻辑非 ！，逻辑与 &amp;&amp; ，逻辑或 || 等于和不等于（==、!=）：操作符先进行类型转换 全等和不全等（===，!==）：不转换 for-in：枚举对象中的非符号键属性 for-of：遍历可迭代对象的元素 switch语句：在比较条件值时使用全等操作符 变量、作用域与内存变量可包含：6种原始值、引用值（由多个值构成的对象） typeof：判断变量是否为字符串、数值、布尔值或undefined instanceof：判断对象的类型 垃圾回收策略：标记清理、引用计数 内存泄漏： 意外声明全局变量 定时器未清理 使用闭包 构造函数：用来创建新对象的函数（使用new操作符） 为方便操作原始值而提供的3种特殊引用类型：Boolean、Number、String Number类型方法：toFixed()、isInteger() String类型方法：charAt()、slice()、substr()、substring()、indexOf()、lastIndexOf()、startsWith()、endsWith()、includes()、trim()、trimleft()、trimright()、toLowerCase()、toUpperCase()、padStart()、padEnd() 集合引用类型Array类型：Array.from()、Array.of()、Array.isArray()、keys()、values()、entries() copyWithin()：按范围浅复制内容后插入指定位置 fill()：向数组中插入值（替换） join()：改变分隔符 push()：添加到数组末尾，返回最新长度 pop()：删除最后一项，返回被删值 shift()：删除第一项并返回 unshift()：开头添加任意多个值，返回长度 排序：reverse()、sort() concat()：创建现数组副本，将参数添至末尾，返回新数值 splice()： 删除：位置、数量 插入：位置、数量（0）、参数 替换：位置、数量、参数 搜索方法： indexof()、lastIndexof()：返回位置/-1 includes()：返回布尔值 find()：返回匹配元素 findIndex()：返回索引 迭代方法： every()：对每一项运行传入的函数，每个返回true则true some()：对每一项运行传入的函数，有一个返回true则true filter()：对每一项运行传入的函数，返回true的项组成数组返回 map()：对每一项运行传入的函数，返回每次函数调用的结果组成的数组 forEach()：对每一项运行传入的函数，没有返回值，相当于使用for循环遍历 归并： reduce()：返回的结果作为下次调用同个函数的第一个参数，最终构建一个返回值（接收参数：上一个归并值、当前项、当前项目索引、数组本身） reduceRight()：方向相反（遍历元素的方向） Map可使用new初始化 使用set()添加键/值对 使用get()、has()查询（失败时返回false、undefined） 使用size()属性获取数量 使用delete()、clear()删除值 可使用任何JS数据类型作为键，会维护键值对插入顺序 选择Map还是Object： 大量删除操作、内存固定大小下多存储 ——&gt; Map 大量查找 ——&gt; Object Set与Map相似 定义了默认迭代器的原生集合类型： Array、定型数组、Map、Set 对象、类与面向对象编程对象：内部特性：不能直接访问，用两个中括号括起来[[…]]，修改方法：Object,defineProperty() 合并对象：Object.assign() 可计算属性：动态属性赋值，[]包围，作为JS表达式来求值 对象解构： 嵌套解构 部分解构 null、undefined不能被解构 创建对象工厂模式： 解决创建多个类似对象问题 没有解决对象标识问题（创建的对象是什么类型） 构造函数模式： 与工厂模式区别： 没有显式创建对象 属性和方法直接赋值给this 没有return 原型模式： 原型对象：定义的属性和方法可以被对象实例共享 实例通过 __proto__ 链接到原型对象 构造函数通过prototype属性链接到原型对象 Object.getPrototypeOf()：取得一个对象的原型 添加同名属性会遮蔽原型对象的同名属性，可通过delete操作符恢复 hasOwnProperty()：确定某属性在实例上还是在原型对象上 in操作符：通过对象访问指定属性返回true，无论属性在原型还是实例上 Object.key()、Object.values()、Object.entries()：接收一个对象，返回对象的可枚举的属性、值、键/值对的数组 重写构造函数上的原型之后再创建的实例才会引用新的原型。在此之前的实例仍引用最初的原型 原型模式是实现所有原生引用类型的模式 产生问题： 弱化了向构造函数传递初始化参数的能力 共享特性 a instanceof b：如果实例（a）的原型链中出现相应的构造函数，则返回true b.prototyoe.isPrototypeOf(a)：原型链中的每个原型都可调用这个方法，若包含这个原型（b）则返回true 函数定义方式： 函数声明 函数表达式 箭头函数 Function构造函数 箭头函数：语法简洁，但不能使用arguments、super、new.target，不能用作构造函数，没有prototype属性 使用function关键字定义时可访问arguments对象，是一个类数组对象 arguments的callee属性：指向arguments对象所在函数的指针 默认参数：按顺序初始化，后面定义的可引用先前定义的，反之不可以 函数声明提升：函数声明在任何代码执行之前先被读取并添加到执行上下文 this： 标准函数中this引用的是把函数当成方法调用的上下文对象 箭头函数中this引用的是定义箭头函数的上下文 new.target属性： 检测函数是否使用new关键字调用 正常调用则值是undefined new调用则值引用被调用的构造函数 函数的自有属性：length、prototype 函数的自有方法： call()、apply()：将任意对象设置为任意函数的作用域 bind()：创建新函数实例，其this值绑定传给bind()的对象 闭包：指引用了另一个函数作用域中的变量的函数 在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域中 过度使用闭包可能导致内存过度占用 事件时间流： 事件冒泡：被点击的元素最先触发事件 事件捕获：在事件到达最终目标前拦截事件 事件处理程序的赋值和移除： addEventListener()、removeEventListener()：接收三个参数（事件名（类型），处理函数，布尔值（false：冒泡，true：捕获）） 优势：为同一个事件添加多个处理程序 event对象：传给事件处理函数的唯一参数 相关属性： currentTarget：当前处理程序所在的元素 Target：事件目标 type：事件类型 stopPropagation()：阻止事件流传播 事件类型：用户界面、焦点、鼠标、滚轮、输入、键盘等 事件委托：给所有元素共同的祖先节点添加一个事件处理函数（通过判断event.target） 删除事件处理程序： 删除某个元素前手工删除某事件处理函数，确保内存被回收 页面卸载之前删除所有事件处理程序 优化：最佳实践可维护性： 注释 变量和函数命名 变量类型透明化 解耦HTML/JS、CSS/JS 尊重对象所有权，不给实例或原型添加方法和属性，不重定义已有的方法，不声明全局变量 不比较null，用instanceof、typeof检查 使用常量（URL、重复出现的值） 性能： 作用域意识：避免全局查找、不使用with语句 避免不必要的属性查找（保存相关内容的引用） 优化循环（终止条件、循环体…） 避免重复解释（JS代码解释JS代码） 使用原生方法、switch语句、位操作 语句最少化（变量声明、迭代性值、字面量） 优化DOM交互（文档碎片、事件委托…）","categories":[],"tags":[]},{"title":"关于HTML语义化","slug":"html semantic meaning","date":"2021-05-05T05:14:50.000Z","updated":"2021-07-10T16:57:10.188Z","comments":true,"path":"2021/05/05/html semantic meaning/","link":"","permalink":"http://example.com/2021/05/05/html%20semantic%20meaning/","excerpt":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。","text":"语义化:​ 传达关于标签所包含的内容类型的一些信息，直观地认识标签的用途 意义:​ （1）对搜索引擎友好（seo优化），搜索引擎根据标签来确定上下文和各个关键字的权重，有良好的结构和语义的网页容易被搜索引擎抓取，有利于网站的推广； ​ （2）在页面没有样式（css属性）的情况下也能够呈现出很好的内容结构； ​ （3）便于团队开发和维护，减少差异化。 部分语义化标签示意: 选用html标签的注意事项：​ （1）少用无语义的标签div和span； ​ （2）既可以使用div或者p时尽量用p: 因为p在默认情况下有上下间距，有利于兼容特殊终端； ​ （3）需要强调的文本，可以包含在strong或em标签中，strong默认样式是加粗（不要用b），em是斜体（不要用i）； ​ （4）每个input标签对应的说明文本都需要使用label标签，在lable标签中设置 for = id 来关联说明文本和相对应的input； 常见语义化标签:​ hn：h1~h6，分级标题，h1 与 title 协调有利于搜索引擎优化 ​ ul：无序列表 ​ ol：有序列表 ​ header：页眉通常包括网站标志、主导航、全站链接以及搜索框 ​ nav：标记导航，仅对文档中重要的链接群使用 ​ main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能 ​ article：定义外部的内容，其中的内容独立于文档的其余部分 ​ section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 ​ aside：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等 ​ footer：页脚，只有当父级是body时，才是整个页面的页脚 ​ small：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权 ​ strong：和 em 标签一样，用于强调文本，但它强调的程度更强一些 ​ em：将其中的文本表示为强调的内容，表现为斜体 ​ mark：使用黄色突出显示部分文本 ​ figure：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin） ​ figcaption：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置 ​ cite：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题 ​ blockquoto：定义块引用，块引用拥有它们自己的空间 ​ time：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式 ​ abbr：简称或缩写 ​ dfn：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用 ​ del：移除的内容 ​ ins：添加的内容 ​ code：标记代码 ​ meter：定义已知范围或分数值内的标量测量 ​ progress：定义运行中的进度（进程）","categories":[],"tags":[]},{"title":"计算机网络概论 学习笔记","slug":"how networks work","date":"2021-04-15T11:53:25.000Z","updated":"2021-07-09T13:07:31.169Z","comments":true,"path":"2021/04/15/how networks work/","link":"","permalink":"http://example.com/2021/04/15/how%20networks%20work/","excerpt":"浏览器解析URL例如确定服务器和文件名，生成HTTP消息 HTTP状态码 1xx 告知请求的处理进度和情况 2xx 成功 3xx 表示需要进一步操作 4xx 客户端错误 5xx 服务器错误","text":"浏览器解析URL例如确定服务器和文件名，生成HTTP消息 HTTP状态码 1xx 告知请求的处理进度和情况 2xx 成功 3xx 表示需要进一步操作 4xx 客户端错误 5xx 服务器错误 协议栈： 查询IP地址根据域名查询：调用操作系统的Socket库（寻找DNS服务器） 向服务器发送消息调用Socket库： 创建套接字（分配内存，记录通信对象IP地址、端口号、操作进行状态等控制信息），返回描述符 将管道连接到服务器的套接字（根据描述符、服务器IP、端口号），双方交换控制信息 客服端设置序号、窗口大小、SYN比特，创建TCP头部，发送——&gt; 服务器设置ACK控制位、计算序号（ACK号）、SYN比特，返回信息——&gt; SYN为1则连接成功，客户端设置ACK控制位、ACK号返回信息给服务器 收发数据 TCP按照网络包大小拆分数据，设置ACK号，加上TCP头部，发送——&gt; 过程中更新ACK号、滑动窗口大小（接受数据最大量）——&gt; 接受数据到缓冲区 断开管道并删除套接字 客户端发送FIN 服务器返回ACK号 服务器发送FIN 客户端返回ACK号 等待一段时间后再删除（防止误操作） IP与以太网的包收发操作TCP模块在执行连接、收发、断开等操作时需要IP模块将数据封装成包 包：头部 + 数据 IP模块为包加上MAC头部和IP头部 路由器（通常内置了集线器和交换机的功能）：根据目标地址（MAC地址）判断下一个路由器位置（路由器存有IP协议表，转发（IP）模块根据其协议表及包的头部IP信息查找接收方；接受方的MAC地址则通过ARP查询） 路由器附加功能： 地址转换：设置私有地址和改写端口号 包过滤 集线器：在子网中将网络包传输到下一个路由（根据以太网协议工作，将IP和负责传输的网络分开可根据需要使用各种通信技术） 将IP转换成信号发送网卡从IP模块获取包，在开头加上报头（读取时机）、起止分界符（起始位置），在末尾加上FCS（帧校验序列） 服务器的包传输（IP—&gt;TCP）接收方IP地址正确则接收，分片重组，TCP模块根据头部的套接字信息进行操作 何时使用UPD协议进行收发操作 短数据 音频、视频数据 通过接入网到达网络运营商POP路由器接入网：连接互联网与家庭、公司网络的通信线路 进入互联网内部的接入网技术：CATV、电话线、ADSL（不对称数字用户，上下行速率不同）和FTTH（光纤） WEB服务器防火墙的包过滤规则： 端口号限定 控制位判断（SYN为1、ACK为0） 地址转换 负载均衡 使用负载均衡器分配访问 使用缓存服务器分担负载（反向代理） 使用内容分发服务分担负载 数据收发 创建套接字 将套接字设置为等待连接状态 创建等待连接套接字的新副本，接受连接 收发数据 断开管道并删除套接字 访问控制规则： 客户端IP地址 客户端域名 用户名和密码","categories":[],"tags":[]},{"title":"浏览器运行原理","slug":"browser works","date":"2021-04-15T06:03:43.000Z","updated":"2021-04-30T06:04:03.112Z","comments":true,"path":"2021/04/15/browser works/","link":"","permalink":"http://example.com/2021/04/15/browser%20works/","excerpt":"用户界面展示除标签页窗口外的其它用户界面内容 浏览器引擎在用户界面和渲染引擎之间传递数据 渲染引擎（内核）渲染用户请求的页面内容","text":"用户界面展示除标签页窗口外的其它用户界面内容 浏览器引擎在用户界面和渲染引擎之间传递数据 渲染引擎（内核）渲染用户请求的页面内容 当启动某个程序时，系统会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要通过进程间通信管道 IPC 来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死的时候，由于进程间相互独立，不会影响到整个应用程序。进程可以将任务分成多个更细小的任务，然后通过创建多个线程，并行执行不同的任务。同一进程下的线程之间是可以直接通信共享数据的。 早期的浏览器并不是多进程的结构，而是个单进程结构。单进程结构引发的问题: （1）不稳定，其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，有一个标签页卡死，可能会导致整个浏览器无法正常运行。 （2）不安全，线程之间是可以共享数据的，线程可以随意访问进程内的数据。 （3）不流畅，一个进程需要负责太多事情，影响运行效率。 多进程浏览器结构: 根据进程功能不同来拆解浏览器，如网络进程负责发起接受网络请求，GPU 进程负责图形渲染，插件进程负责控制网站使用的所有插件（例如 Flash ），渲染器进程用来控制显示tab标签内的所有内容。 浏览器（ chrome 为例）在默认情况下会为每个标签页都创建一个进程: 为用户访问的网站的每个实例创建一个渲染器进程。这样可以确保来自不同站点的页面是独立呈现的，并且对同一站点的单独访问也是彼此隔离的。简单来说就是访问不同站点和同一站点的不同页面都会创建新进程。如果网页中嵌入了 iframe ， chrome 会出于安全考虑为每个 iframe 都创建了一个进程，通过多进程让当前的主站点和 iframe 里的站点之间隔离。 四种进程模型（文档地址: https://www.chromium.org/developers/design-documents/process-models ）: 默认的 Process-per-site-instance Process-per-site: 同一站点使用同一进程。 Process-per-tab: 一个tab里的所有站点使用一个进程。 Single process: 让浏览器引擎和渲染器引擎共用一个进程。 Process-per-site-instance 模型会创建更多的进程占用更多的内存空间，但最安全。每个标签，以及标签内的每个站点都是相互隔离互不影响的。当其中一个标签页里渲染器进程卡死，并不会影响其他标签。 浏览器渲染原理当在地址栏输入地址时，浏览器进程的 UI 线程会捕捉输入内容，如果访问的是网址，则 UI 线程会启动一个网络线程来请求 DNS 进行域名解析接着开始连接服务器获取数据。如果输入的是一串关键词，就会使用默认配置的搜索引擎来查询。 当网络线程获取到数据后，会通过 SafeBrowsing （谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如通过查看该站点的 ip 是否在他们的黑名单内）来检查该站点的是否是恶意站点。如果是则会展示个警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问。当然也可以强行继续访问。 当返回数据准备完毕并且安全校验通过，网络线程会通知 UI 线程，然后 UI 线程会创建一个渲染器进程来渲染页面。浏览器进程通过 IPC 管道将数据（ html ）传递给渲染器进程，正式进入渲染流程。渲染器进程的核心任务就是把 html 、 js 、 css 、 img 等资源渲染成用户可交互的web页面。此时地址栏的状态更新，比如 histroy 更新，现在可以点击导航栏的后退。 渲染器进程的主线程将 html 进行解析，构造 DOM 数据结构。 DOM 文档对象模型是浏览器对页面在其内部表示形式，是 Web 程序员可以通过 JavaScript 与之交互的数据结构和 API 。 HTML 首先经过 Tokeniser 标记化，通过词法分析，将输入 html 内容解析成多个标记，根据识别后的标记进行 DOM 树构造, 在 DOM 树构造过程中会创建 Document 对象，然后以 Document 为根节点的DOM树不断进行修改，向其中添加各种元素。 HTML 代码中往往会引入一些额外的资源，比如图片， css 和 js 脚本等。图片和 css 这些资源需要通过网络下载或者从缓存中直接加载。这些资源不会阻塞 html 的解析，因为他们不会影响 DOM 的生成，但当 html 解析过程中遇到script标签，将停止 html 解析流程，转而去加载解析并且执行 js （浏览器不知道 js 的执行是否会改变当前页面的 html 的结构，比如 js 代码了调用 document.write 方法来修改 html ，那之前的 html 的解析就失去意义，所以要把 script 标签要放在合适的位置，或者使用 async 或 defer 属性来异步加载执行 js ）。 在 html 解析完成后，我们就获得一个 dom tree ，但我们还不知道 dom tree 上每个节点应该长什么样。主线程需要解析 css 并确定每个 DOM 节点的 css 样式（浏览器有自己的默认的样式表）。 在知道 dom 结构和每个节点的样式后，需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标，以及该节点需要占用多大的区域。 这个阶段被称为 layout 布局，主线程通过遍历 DOM 和计算好的样式来生成 layout tree ， layout tree 上的每个节点都记录 x 、 y 坐标和边框尺寸。因为 DOM 是通过 html 解析获得，并不关心样式。而 layout tree 是根据 dom tree 和计算好的样式来生成， layout tree 是和最后展示在屏幕上的的节点是对应的。所以 DOM Tree 和 layout tree 并不是一一对应的，设置了 display: none 的节点不会出现在 layout tree 上，而在 before 伪类中添加了 content 值的元素， content 的内容会出现在 layout tree ，不会出现在 DOM 树里。 已经知道元素的大小，形状和位置后还需要知道绘制各个节点的顺序。例: z-index 这个属性会影响节点绘制的层级关系。如果按照 dom 的层级结构来绘制页面，则会导致错误的渲染。 所以为了保证在屏幕上展示正确的层级，在绘制阶段，主线程遍历 layout tree 创建一个绘制记录表，该表记录了绘制的顺序。 知道了文档的绘制顺序后就到了该把这些信息转化成像素点显示在屏幕上了。这种行为，被称为栅格化（ rasterizing ）。浏览器最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式会导致展示延迟。随着不断的优化升级，现在使用了一种更复杂的栅格化流程，叫做 compositing 组合: 一种将页面的各个部分分成多个图层，分别对其进行栅格化并在合成器线程 compositor thread 的单独线程中进行合成页面的技术。简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化，然后只需要把可视区的内容组合成一帧展示给用户。 主线程遍历 layout tree 生成 layer tree ，当 layer tree 生成完毕和绘制顺序确定后，主线程将这些信息传递给 compositor 线程。合成器线程将每个图层栅格化。一层可能像页面的整个长度一样大，因此合成器线程将它们切分为多个图块，然后将每个图块发送给栅格线程。 栅格线程栅格化每个图块并将它们存储在 GPU 内存中。对图块进行栅格化后合成器线程可以给不同的栅格线程分别优先级，比如栅格化可视区域图块的栅格线程优先处理。 当图块栅格化完成后，合成器线程将收集称为 draw quads 图块信息，这些信息里记录了包含诸如图块在内存中的位置和在页面的哪个位置绘制图块的信息。根据这些数据合成器线程生成了一个合成器 frame 。然后 frame 通过 IPC 传送给浏览器进程， 接着浏览器进程将 compositor frame 传到 GPU ，然后 GPU 渲染展示到屏幕上。于是你终于看到了页面内容。当页面发生变化，比如你滚动了当前页面，则会生成一个新的 compositor frame ，新的 frame 再传给 GPU 。再次渲染到屏幕上。 重排：当我们改变一个尺寸位置属性时，会重新进行样式计算，布局，绘制，以及后面的所有流程。 重绘：当我们改变某个元素的颜色属性时，不会重新触发布局，但还是触发会样式计算和绘制。 重排和重绘会占用主线程，还有一个东西的运行也是在主线程。对， js 。既然他们都是在主线程就会出现抢占执行时间的问题。 如果写了个不断导致重绘重排的动画，浏览器则需要在每一帧都会运行样式计算、布局和绘制的操作，当页面以每秒大于60帧的刷新率刷新，用户才不会感觉到页面卡顿。 如果在运行动画时，有大量的 js 任务需要执行，因为布局绘制和 js 的执行都是在主线程运行的，当在一帧的时间内，布局和绘制结束后，还有剩余时间， js 就会拿到主线程的使用权，如果 js 执行时间过长就会导致在下一帧开始时， js 没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿。优化手段: 第一种：就是可以通过 requestAnimationFrame 这个 api 来帮助我们解决这个问题。 requestAnimationFrame 这个方法会在每一帧被调用，通过这个 api 的回调参数，我们可以知道每一帧当前还剩余的，我们可以把 js 运行任务分成一些小块，在时间用完前，归还主线程。 第二种：栅格化整个流程是不占用主线程的，只在合成器和栅格线程中运行，这就意味着它无需和 js 抢夺的主线程。刚才提到，如果我们反复重绘和重排，可能会导致掉帧，因为有可能会有 js 的执行阻塞了主线程。 css 中有个动画属性叫 transform ，通过该属性实现的动画，不会经过布局和绘制，而是直接运行在 compositor 和 rasterizing 线程中，所以不会受到主线程中js执行的影响。更重要的是 transform 的动画，由于不需要经过布局绘制样式计算，所以节省了很多运算时间。可以让复杂的动画更加流畅。我们常常会哪些属性来实现动画效果呢，位置变化，宽高变化，那这些都可以使用 transform 来代替。","categories":[],"tags":[]},{"title":"JS 事件循环","slug":"js event loop","date":"2021-04-06T07:37:55.000Z","updated":"2021-04-19T14:52:13.067Z","comments":true,"path":"2021/04/06/js event loop/","link":"","permalink":"http://example.com/2021/04/06/js%20event%20loop/","excerpt":"关于 JS 异步js 作为浏览器端的脚本语言，主要的用途为用户与服务端的交互与操作 dom 。而操作 dom 就注定了 js 只能是单线程语言，假如多个线程同时对一个 dom 进行操作则浏览器无法判断如何渲染。（在浏览器中 js 引擎负责解释和执行JavaScript代码的线程只有一个）。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。同步会阻塞代码的执行，而异步不会。事件循环（event loop）是 js 异步的实现方式。","text":"关于 JS 异步js 作为浏览器端的脚本语言，主要的用途为用户与服务端的交互与操作 dom 。而操作 dom 就注定了 js 只能是单线程语言，假如多个线程同时对一个 dom 进行操作则浏览器无法判断如何渲染。（在浏览器中 js 引擎负责解释和执行JavaScript代码的线程只有一个）。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。同步会阻塞代码的执行，而异步不会。事件循环（event loop）是 js 异步的实现方式。 事件循环的三个部分：调用栈call stack循环开始后从全局栈开始一行一行执行，遇到函数调用就压入调用栈中（压入的函数称为帧frame）,函数返回后从调用栈弹出 消息队列message quenesetTimeout、setInterval、setlmmediate等异步操作的回调函数会入队到消息队列，在调用栈清空后执行（一个循环结束后），执行顺序为先进先出 js 异步操作主要有： 1、定时任务（setTimeout、setInterval） 2、网路请求（ajax、动态加载） 3、事件处理函数绑定（click，focus，change等） 微任务队列microtask quenePromise回调、await、async、MutationObserver等操作会入队到微任务队列，在调用栈清空时立即执行，处理时新加入的微任务也一起执行（一个循环结束时） 示例代码:1234567891011121314151617181920212223242526272829303132var p = new Promise(resolve =&gt; &#123; console.log(4); resolve(5);&#125;);function fun1() &#123; console.log(1);&#125;function fun2() &#123; setTimeout(() =&gt; &#123; console.log(2); &#125;); fun1(); console.log(3); p.then(resolved =&gt; &#123; console.log(resolved) &#125;) .then(() =&gt; &#123; console.log(6) &#125;);&#125;fun2();// 打印顺序为413562for(var i = 0; i&lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i++); &#125;)&#125;console.log(i);//打印顺序为556789","categories":[],"tags":[]},{"title":"JS 防抖和节流","slug":"debounce and throttle","date":"2021-04-03T14:22:14.000Z","updated":"2021-04-03T14:23:05.708Z","comments":true,"path":"2021/04/03/debounce and throttle/","link":"","permalink":"http://example.com/2021/04/03/debounce%20and%20throttle/","excerpt":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想","text":"防抖:减少事件的触发, 一段时间内只有一次触发（在产生事件时取消上一次事件，开启新定时器），如窗口变化、搜索框联想 1234567let timer &#x3D; null;aElement.click &#x3D; function&#123; clearTimeout(time); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; console.log(&quot;debounce successfully&quot;) &#125;, 1000)&#125; 节流减少事件的触发, 降低触发频率（在产生事件时判断节流阀，成立时（true）把节流阀设置为不成立（false）, 触发事件, 开启新计时器重置节流阀（true）) 12345678let flag = true;if(flag)&#123; flag = false; console.log(&quot;throttle successfully&quot;); setTimeout(() =&gt; &#123; flag = true; &#125;, 1000)&#125; 前往 https://www.lodashjs.com/ 获取封装好的方法: .debounce、.throttle（利用script标签引用网站的lodash.js文件）","categories":[],"tags":[]},{"title":"JS 浅拷贝和深拷贝","slug":"deepcopy and shallowcopy","date":"2021-04-03T13:47:40.000Z","updated":"2022-01-13T03:35:04.781Z","comments":true,"path":"2021/04/03/deepcopy and shallowcopy/","link":"","permalink":"http://example.com/2021/04/03/deepcopy%20and%20shallowcopy/","excerpt":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址）","text":"值类型number、string、boolean 引用类型object、array 赋值区别值类型赋值时将变量内容赋予新的变量，引用类型赋值时将指针进行赋予（指向同样的内存地址） 浅拷贝: 只循环了第一个层级1234567function copyShallow(a)&#123; let newObj = &#123;&#125;; for(let key in a)&#123; newObj[key]= a[key]; &#125; return newObj&#125; 深拷贝: 深度遍历, 直到所有属性的值都为值类型（1）前往 https://www.lodashjs.com/ 获取封装好的方法: _.cloneDeep（利用script标签引用网站的lodash.js文件） （2）将对象序列化成字符串, 再将字符串反序列化 1JSON.parse(JSON.stringify(object)) （3）手写深拷贝 12345678910111213141516171819function copyDeep(a)&#123; if(typeof a !== &#x27;object&#x27; || a == null)&#123; return a &#125; let result; if(a instanceof Array)&#123; result = []; &#125;else&#123; result = &#123;&#125;; &#125; for(let key in a)&#123; result[key] = copyDeep(a[key]) &#125; return result;&#125; （4）第（2）、（3）方法无法拷贝的属性值有underfined、symol、function、error、regexp等类型，如需拷贝则另作处理 拷贝函数： 12function aFun(a, b, c)&#123; return a * b * c; &#125; var copyF = new Function(&#x27;return &#x27;+ aFun.toString())(); 拷贝error、regexp： 12345var _constructor = target.constructor; //引用对应类型的constructor属性new _constructor(target); // regexp类型new _constructor(target.message); // error类型","categories":[],"tags":[]},{"title":"跨域（Cross-origin resource sharing）相关","slug":"about the CORS","date":"2021-04-01T00:43:44.697Z","updated":"2021-07-15T04:31:47.906Z","comments":true,"path":"2021/04/01/about the CORS/","link":"","permalink":"http://example.com/2021/04/01/about%20the%20CORS/","excerpt":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互","text":"跨域: 出于浏览器的同源策略限制, 会阻止一个域的javascript脚本和另外一个域的内容进行交互 常见解决方案: （1）HTML特殊标签 link、script、img、frame等标签具有跨域特性, 可直接访问 （2）cors 普通跨域请求只需服务器端设置（以php为例） 1header(“Access-Control-Allow-Origin: *”) 带cookie跨域请求：前后端都需要进行设置 ? （3）proxy代理（开发环境用proxy，生产环境用nginx反向代理） 利用服务器对数据进行转发, 以proxy为例 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; &quot;/api&quot;: &#123; //表示是否需要跨域，接口地址以/api开头则跨域 target: &quot;&quot;, //设置调用的接口域名和端口号 changeOrigin: ture, //开启代理，在本地创建一个虚拟服务器 pathRewrite:&#123; &quot;^api&quot;: &quot;/&quot; &#125; &#125; &#125; &#125;&#125; （4）jsonp 利用script标签远程动态加载js代码, 只支持get方法 123456$ajax(&#123; type: &quot;get&quot;, url: &quot;&quot;, dataType: &quot;jsonp&quot;, success: function (response)&#123;&#125;&#125;)","categories":[],"tags":[]},{"title":"flex布局 用法记录","slug":"flex use","date":"2021-03-29T13:30:40.890Z","updated":"2021-03-31T08:43:48.430Z","comments":true,"path":"2021/03/29/flex use/","link":"","permalink":"http://example.com/2021/03/29/flex%20use/","excerpt":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素）","text":"flex container: 开启flex布局的元素 flex items: flex container里的直接子元素 开启方法: 设置元素的css属性 display: flex（块级元素）或 inline-flex（行内元素） flex模型相关尺寸:flex constainer的css属性：flex-flow（缩写，flex-direction||flex-wrap） flex-direction（决定主轴方向）: row（默认）, row-reverse，column（主轴从上到下），column-reverse flex-wrap（单行/多行）: nowrap，wrap，wrap-reverse justify-content（决定flex items在main-axis上的对齐方式）: flex-start（默认），flex-end，center，space-between，space-evenly，space-around align-items（决定flex items在cross-axis上的对齐方式）: normal（默认），strech（效果同normal, flex items在cross-axis方向的size为auto时, 自动拉伸），flex-start，flex-end，center，baseline align-content（决定多行flex-items在cross axis上的对齐方式）: strech，flex-start，flex-end，center，space-berween，space-around，space-evenly flex items的css属性:flex（缩写，flex-grow||flex-shrink||flex-basis） flex-grow（决定flex items如何扩展，flex container在main axis方向有剩余size时才生效）: 可设置任意非负数，所有flex items的flex-grow总和 sum 超过1，扩展size为 剩余size * flex-grow / sum ，不超过1时扩展size为 剩余size * flex-grow flex-shrink（决定flex items如何收缩, flex items在main axis方向上超过flex container的size时才生效）: 可设置任意非负数，收缩后的size不能小于min-width/min-height，所有flex items的flex-shrink总和 sum 超过1，收缩的size为 超出size * flex-shrink * items base size / sum ，不超过1时收缩的size为 超出size * flex-shrink * items base size flex-basis（设置flex items在main axis方向上的base size）: auto， 具体数值（？px） 生效的优先级: （1）max-width/max-height/min-width/min-height （2）flex-basis （3）width/higth （4）自身size order（决定flex-items排布顺序，设置任意整数，值越小排布越靠前） align-self（单独效果，覆盖flex container设置的align-items）: auto（默认），stretch，flex-start，flex-end，center，baseline","categories":[],"tags":[]},{"title":"vue.js 学习笔记","slug":"vuejs learning","date":"2021-03-29T11:32:44.000Z","updated":"2022-01-08T11:40:10.993Z","comments":true,"path":"2021/03/29/vuejs learning/","link":"","permalink":"http://example.com/2021/03/29/vuejs%20learning/","excerpt":"vue生命周期vue2.0生命周期函数： 创建期间 beforeCreate()：实例刚被创建出来，data和methods还没初始化 created()：data和methods已经初始化，模板还未编译 beforeMount()：完成编译，还未挂载 mounted()：将模板挂载显示","text":"vue生命周期vue2.0生命周期函数： 创建期间 beforeCreate()：实例刚被创建出来，data和methods还没初始化 created()：data和methods已经初始化，模板还未编译 beforeMount()：完成编译，还未挂载 mounted()：将模板挂载显示 运行期间 beforeUpdate()：data状态值更新（数据被修改）之前执行，状态值新，页面值旧 updated()：状态值和页面值都已完成更新 销毁期间 beforeDestroy()：准备销毁，实例属性和方法仍可用 destroyed()：已经销毁，实例所有内容均不可用 vue.js特点：解耦视图和数据、组件复用、路由状态管理、虚拟DOM 编程范式：声明式编程 v-for：基于源数据多次渲染元素或模板块 v-pre：跳过这个元素和它的子元素的编译过程，可跳过没有使用指令语法、没有使用插值语法的节点，加快编译 v-clock：该指令保持在元素上直到关联组件实例结束编译，与css一起使用可隐藏元素直至组件编译完成 v-bind：动态地绑定一个或多个 attribute，或一个组件 prop 到表达式 v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过 v-html：更新元素的innerHTML v-model：在表单控件或者组件上创建双向绑定 v-slot：1、具名插槽，在指定的位置输出一些子元素；2、作用域插槽，在书写插槽内容时可以获取插槽作用域的值 v-if、v-else-if、v-else：根据表达式的真假值来有条件地渲染元素 v-show：根据表达式的真假值，切换元素的 display v-show和v-if：是否渲染（display: none）和改变样式（不存在于DOM） v-on：绑定事件监听器，监听原生dom事件或自定义事件 v-model修饰符：在表单控件或者组件上创建双向绑定 组件的date是函数：复用时调用同组件的data函数每次返回一个新对象 runtime-compiler和runtime-only：only模式打包体积更小，但template标签只能写在 .vue文件中 Babel：工具链，将ECMAScript2015+版本的代码转换为向后兼容的JS语法，以便能运行在当前和旧版本的环境中 组件通信父传子：子组件定义props，props属性里的变量绑定父组件的变量 数组方式 对象方式，可指定类型。default：定义默认值；required：为true时表示必传 指定类型为对象或数组时，默认值从工厂函数获取（default: function() { return {…} }） 指定值为一定范围：变量名: {validator: function (value) { return [“…”, “…”, “…”].indexof(value) !== -1 }} 子传父： 子组件方法内自定义事件a，事件a内添加 this.$emit(“事件a”, 传参) 父组件调用子组件的标签内监听 @事件a = “事件b” ，然后定义事件b处理 兄弟组件间： 子1传父再父传子2 创建一个js文件，新建并导出一个vue实例（bus）。在需要通信的兄弟组件导入该js文件， 发送使用bus.$emit，接受使用bus.$on 插槽 子组件模板内使用&lt;slot&gt;&lt;/slot&gt;，父组件使用子组件标签内添加插槽内容，可在slot标签内添加默认内容 具名插槽：在slot标签内添加name属性，在替换内容的标签内添加 slot=“name属性名” vue模板文件内使用：父组件使用子组件标签内添加的插槽内容格式 &lt;template v-slot: name属性名&gt;&lt;/template&gt; computed和watch使用computed： 一个属性是由其他属性计算而来的，依赖于其他属性，是多对一或一对一 具有缓存功能，在重复的调用中只要依赖数据不变，直接取缓存中的计算结果；当依赖的数据发生改变时才重新计算 不支持异步，在computed内执行异步操作会报错 在computed中所有属性都有get()和set()，一般执行get()，当属性被直接修改时执行set() 使用watch： 一个数据的变化影响多个数据， 或在变化时需要执行异步操作，可用于监控$route、input输入值 通过vm对象$watch()或watch()配置监听Vue实例的属性或特定数据的变化，然后执行具体的业务逻辑、操作。当监听内容变化时回调函数自动调用、进行计算，监听数据来源：data、props，computed、$route内的数据 监听函数可接收两个参数，新值和旧值，或只有新值 默认为浅监听，若要监听复杂数据类型则在选项参数中指定deep: true （深度监听），但仍然无法监听具体属性的变化，解决方法：1、配合computed使用；2、直接监听对象属性 在computed中所有属性都有handle方法和immediate属性，immediate为true时立即执行handle方法（本来watch在开始监视（最初绑定）时不执行） 模块化规范CommonJs（需node环境） 导出：module.exports = {}（导出的是对象） 导入：let {} = require(“路径”) ES6 导出：export {} 导入：import {} from “路径” （存在默认导出内容时无需中括号） 前后端分离： 后端渲染：html+css+java ( jsp、php )，后端处理URL和页面的映射关系，服务器渲染页面然后返回客户端浏览器显示，有利于SEO优化，但代码逻辑混乱 前端渲染（前后端分离）：后端只负责数据（提供API），从静态资源服务器取html+css+js，从提供API接口的服务器获取数据，有其他js代码一起渲染成页面 单页面富应用：前端路由管理映射关系 路由映射路由重定向：具体某个路由映射关系内添加选项 redirect: “路径” 路由嵌套：映射关系内添加children选项 路由懒加载：将路由对应的组件打包成js代码块，被访问时才加载：const 组件名 = () =&gt; import ( “路径” ) router-link：声明式导航 this.$route.push(“/“)：编程式导航 使用：&lt;route-link to=”/about” tag=”button” replace&gt;about页面&lt;/route-link&gt; replace：不会留下history记录 tag：指定route-link渲染成什么组件 路由参数传递： 1、params类型 在路由映射关系内添加 path: “/about/:abc” （abc命名无意义） route-link标签内 to=“ ’/about/‘ + b ” about组件内添加计算属性 b{ return this.$route.params.a } 其中a的值在父组件data属性内定义 2、query类型 route-link标签内 :to=”{ path: “……”, query: {……}}” 子组件取得数据 $route.query 导航守卫作用：监听全局跳转，具有多种形式：全局、单个路由独享、组件级 router.beforeEach：全局前置守卫 router.afterEach：全局后置钩子 router.beforeResolve：全局解析守卫，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用 组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 完整的导航解析流程 导航被触发：在失活的组件里调用 beforeRouteLeave 调用全局的 beforeEach 在重用的组件里调用 beforeRouteUpdate 在路由配置里调用 beforeEnter 在被激活的组件里调用 beforeRouteEnter 调用全局的 beforeResolve 导航被确认：调用全局的 afterEach 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入 每个守卫方法接收三个参数(to, from, next)： to： 即将要进入的目标 路由对象 from：当前导航正要离开的路由 next：执行效果依赖 next 方法的调用参数： next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed next(false)：中断当前的导航。如果浏览器的 URL 改变了（用户手动或者浏览器后退按钮）， URL 地址重置到 from 路由对应的地址 next(‘/‘) 或者 next({ path: ‘/‘ })： 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航 next(error)： 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调 Vuex 状态管理工具使用Vuex：集中存储、管理应用的所有组件的状态（公共数据），并以相应的规则保证状态以一种可预测的方式发生变化 state：设置公共数据 mutations：设置方法，在组件内提交 this.$store.commit( “方法名”, 传参) getters：类似于计算属性 actions：有异步操作时代替mutations。设置 a(context) {…异步操作… context.commit(“在mutations中定义的方法名”)} 在组件内提交 this.$store.dispatch(“在mutations中定义的方法名”) 其中context是自带属性 mudules：模块，通过新建对象定义新模块 const moduleA = {……}，每个模块可拥有自己的state、mutations等选项 使用 a : moduleA 选择 store.state.a","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-29T11:13:57.110Z","updated":"2021-03-29T13:12:17.543Z","comments":true,"path":"2021/03/29/hello-world/","link":"","permalink":"http://example.com/2021/03/29/hello-world/","excerpt":"","text":"2021.3.29 Set up my blog successfully","categories":[],"tags":[]}],"categories":[],"tags":[]}